// Multiplies R0 and R1 and stores the result in R2.
// (R0, R1, R2 refer to RAM[0], RAM[1], and RAM[2], respectively.)
// The algorithm is based on repetitive addition.

@R2
M=0
(LOOP)
@R1
D=M
@END
D;JEQ
@R0
D=M
@R2
M=D+M
@R1
M=M-1
@LOOP
0;JMP
(END)
@END
0;JMP

/*
// PC = 0
// R0 = 5
// R1 = 4
// R2 = 0

0. @R2 // в регистр А кладем адрес 2 | PC = 0 (+1)
1. M=0 // по адресу 2 в регистр памяти зписываем значение 0 | PC = 1 (+1)
(LOOP) //  ассмблер привязывает метку к адресу след. инструкции (2)
2. @R1 // записываем в регистр адреса адрес 1 | PC = 2 (+1)
3. D=M // записываем в регистр данных D значение 4 из регистра памяти M по адрессу А | PC = 3 (+1)
4. @END // записываем в регистр адреса адрес 13 | PC = 4 (+1) 
5. D;JEQ // делаем проверку на 0, если 0,то записываем в PС = А (13) | PC = 5,если нет прыжка то PС+1
6. @R2 // записываем в регистр адреса значение 2 | PC = 6 (+1) 
7. M=D+M // записываем в регистр памяти по адресу 2 значение суммы регистр памяти по адресу 2 и регистра данных D | PC = 7 (+1) 
8. @R1 // записываем в регистр адреса значение 1 | PC = 8 (+1) 
9. M=M-1 // вычитаем из регистра памяти 1 иперезаписываем в этот регистр новое число | PC = 9 (+1) 
10. D=M // записываем в регистр данных значение из регистра памяти по текущему адресу А | PC = 10 (+1) 
11. @LOOP // записываем в регистр адреса значение 2 которое мы привязали меткой | PC = 11 (+1) 
12. 0;JMP // записываем в PС = А (2) | на текущий момент (PC = 12)
 (END) ассемблер связывает метку END с адресом 13 для PC  
13. @END // записываем в регистр адреса адрес 13 | PC = 13 (+1) 
14. 0;JMP // записываем в PС = А (13) | (на текущий момент PC = 14)
*/